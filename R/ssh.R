#' Open a cloud SSH browser for an instance
#' 
#' This will open an SSH from the browser session if \code{getOption("browser")} is not NULL
#' 
#' You will need to login the first time with an email that has access to the instance.
#' 
#' @seealso \url{https://cloud.google.com/compute/docs/ssh-in-browser}
#' 
#' @param instance Name of the instance resource
#' @param project Project ID for this request, default as set by \link{gce_get_global_project}
#' @param zone The name of the zone for this request, default as set by \link{gce_get_global_zone}
#' 
#' @return Opens a browser window to the SSH session, returns the SSH URL.
#' @importFrom utils browseURL
#' @export
#' @family ssh functions
gce_ssh_browser <- function(instance,
                            project = gce_get_global_project(), 
                            zone = gce_get_global_zone()){
  
  ssh_url <- sprintf("https://ssh.cloud.google.com/projects/%s/zones/%s/instances/%s?projectNumber=%s",
                     project, zone, instance, project)
  
  if(!is.null(getOption("browser"))){
    utils::browseURL(ssh_url)
  }

  ssh_url
  
}


#' Setup a SSH connection with GCE from a new SSH key-pair
#' 
#' You will need to generate a new SSH key-pair if you have not connected to the instance before. Instructions for this can be found here: \url{https://cloud.google.com/compute/docs/instances/connecting-to-instance}.  Once you have generated run this function once to initiate setup
#' 
#' @param key.pub The contents of the \code{~/.ssh/my-ssh-key.pub} generated by the cat command
#' @param instance Name of the instance of run ssh command upon
#' @param project Project ID for this request, default as set by \link{gce_get_global_project}
#' @param zone The name of the zone for this request, default as set by \link{gce_get_global_zone}
#' 
#' @seealso \url{https://cloud.google.com/compute/docs/instances/connecting-to-instance}
#' 
#' @export
#' @family ssh functions
gce_ssh_setup <- function(key.pub,
                          instance,
                          project = gce_get_global_project(),
                          zone = gce_get_global_zone()){
  
  ## Check to see if they have been set already
  if(file.exists(file.path(Sys.getenv("HOME"), ".ssh", "google_compute_engine.pub"))){
    ## you already have the key
  }
  
  proj <- gce_get_project(project)
  proj_meta <- proj$commonInstanceMetadata$items
  keys <- unlist(strsplit(proj_meta[proj_meta$key == "sshKeys","value"], "\n"))
  

  
  ## set project wide metadata so you can use SSH
  
  
}

#' Remotely execute ssh code, upload & download files.
#'
#' Assumes that you have ssh & scp installed.  
#' 
#' Only works connecting to linux based instances.
#' 
#' On Windows you will need to install an ssh command line client.
#' 
#' You will need to generate a new SSH key-pair if you have not connected to the instance before.
#' 
#' Otherwise, instructions for this can be found here: \url{https://cloud.google.com/compute/docs/instances/connecting-to-instance}.  
#' 
#' When you have generated it run \link{gce_ssh_setup} once to initiate setup.
#'
#' Uploads and downloads are recursive, so if you specify a directory,
#' everything inside the directory will also be downloaded.
#' 
#'
#' @param instance Name of the instance of run ssh command upon
#' @param ... Shell commands to run. Multiple commands are combined with
#'   \code{&&} so that execution will halt after the first failure.
#' @param user User name. This is the login username for your local workstation
#' @param local,remote Local and remote paths.
#' @param verbose If TRUE, will print command before executing it.
#' @param overwrite If TRUE, then overwrite destination files if they already
#'   exist.
#' @param project Project ID for this request, default as set by \link{gce_get_global_project}
#' @param zone The name of the zone for this request, default as set by \link{gce_get_global_zone}
#' 
#' @author Scott Chamberlin \email{myrmecocystus@@gmail.com}
#' @seealso \url{https://cloud.google.com/compute/docs/instances/connecting-to-instance}
#' @return On failure, throws an error.
#' @export
#' @family ssh functions
gce_ssh <- function(instance, 
                    ..., 
                    user, 
                    verbose = FALSE,
                    project = gce_get_global_project(),
                    zone = gce_get_global_zone()) {
  
  lines <- paste(c(...), collapse = " \\\n&& ")
  if (lines == "") stop("Provide commands", call. = FALSE)
  cmd <- paste0(
    "ssh ", ssh_options(),
    " ", user, "@", gce_get_external_ip(instance, project = project, zone = zone),
    " ", shQuote(lines)
  )
  do_system(instance, cmd, verbose = verbose, project = project, zone = zone)
}

ssh_options <- function() {
  opts <- c(
    BatchMode = "yes",
    StrictHostKeyChecking = "no",
    UserKnownHostsFile = file.path(tempdir(), "hosts")
  )
  paste0("-o ", names(opts), "=", opts, collapse = " ")
}


#' @export
#' @rdname gce_ssh
gce_ssh_upload <- function(instance,
                           local, 
                           remote, 
                           user = "root", 
                           verbose = FALSE,
                           project = gce_get_global_project(), 
                           zone = gce_get_global_zone()) {

  cmd <- paste0(
    "scp -r ", ssh_options(),
    " ", local,
    " ", user, "@", gce_get_external_ip(instance, project = project, zone = zone), ":", remote
  )

  do_system(instance, cmd, verbose = verbose, project = project, zone = zone)
}

#' @export
#' @rdname gce_ssh
gce_ssh_download <- function(instance,
                             remote, 
                             local, 
                             user = "root",
                             verbose = FALSE, 
                             overwrite = FALSE,
                             project = gce_get_global_project(), 
                             zone = gce_get_global_zone()) {

  local <- normalizePath(local, mustWork = FALSE)

  if (file.exists(local) && file.info(local)$isdir) {
    # If `local` exists and is a dir, then just put the result in that directory
    local_dir <- local
    need_rename <- FALSE

  } else {
    # If `local` isn't an existing directory, put the result in the parent
    local_dir <- dirname(local)
    need_rename <- TRUE
  }

  # A temp dir for the downloaded file(s)
  local_tempdir <- tempfile("download", local_dir)
  local_tempfile <- file.path(local_tempdir, basename(remote))

  if (need_rename) {
    # Rename to local name
    dest <- file.path(local_dir, basename(local))
  } else {
    # Keep original name
    dest <- file.path(local_dir, basename(remote))
  }

  if (file.exists(dest) && !overwrite) {
    stop("Destination file already exists.")
  }

  dir.create(local_tempdir)

  # Rename the downloaded files when we exit
  on.exit({
    if (file.exists(dest)) unlink(dest, recursive = TRUE)
    file.rename(local_tempfile, dest)
    unlink(local_tempdir, recursive = TRUE)
  })

  # This ssh's to the remote machine, tars the file(s), and sends it to the
  # local host where it is untarred.
  cmd <- paste0(
    "ssh ", ssh_options(),
    " ", user, "@", gce_get_external_ip(instance, project = project, zone = zone), " ",
    sprintf("'cd %s && tar cz %s'", dirname(remote), basename(remote)),
    " | ",
    sprintf("(cd %s && tar xz)", local_tempdir)
  )

  do_system(instance, cmd, verbose = verbose, project = project, zone = zone)
}


do_system <- function(instance, 
                      cmd, 
                      verbose = FALSE, 
                      project = gce_get_global_project(), 
                      zone = gce_get_global_zone()) {
  cli_tools()
  # check to make sure port 22 open, otherwise ssh commands will fail
  if (!is_port_open(gce_get_external_ip(instance, project = project, zone = zone), 22)) {
    stop("port 22 is not open; wait a bit (try 5 - 10 sec.) and try again", call. = FALSE)
  }
  myMessage(verbose, cmd, level = 3)
  status <- system(cmd)
  if (status != 0) {
    stop("ssh failed\n", cmd, call. = FALSE)
  }

  invisible(TRUE)
}

#' Test to see if a TCP port is open
#' 
#' Taken via https://github.com/sckott/analogsea/blob/e728772013ad286750e0e89dc261a36fa31d4647/R/is_port_open.R
#'
#' @param host ip or host name to connect to
#' @param port port to connect to
#' @param timeout how many secs to let it try
#' @noRd
#' @author Bob Rudis \email{bob@@rudis.net}
#' @examples \dontrun{
#' is_port_open("httpbin.org", 80)
#' is_port_open("httpbin.org", 22)
#' }
is_port_open <- function(host, port=22, timeout=1) {
  
  WARN <- getOption("warn")
  options(warn = -1)
  
  socketConnection
  
  con <- try(socketConnection(host, port, blocking = TRUE, timeout = timeout),
             silent = TRUE)
  
  if (!inherits(con, "try-error")) {
    close(con)
    options(warn = WARN)
    TRUE
  } else {
    options(warn = WARN)
    FALSE
  }
  
}

#' See if ssh or scp is installed
#' From https://github.com/sckott/analogsea/blob/master/R/zzz.R
#' @keywords internal
cli_tools <- function(ip){
  tmp <- Sys.which(c("ssh","scp"))
  if (any(tmp == "")) {
    nf <- paste0(names(tmp)[tmp == ""], collapse = ", ")
    stop(sprintf("\n%s not found on your computer\nInstall the missing tool(s) and try again", nf))
  }
}
